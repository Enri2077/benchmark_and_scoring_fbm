#!/usr/bin/env python
import math
import random
import time
import yaml

# ROS imports
import rospy
import tf
from rockin_scoring.BmBox import BmBox

# Benchmark runs
BENCHMARK_RUNS = 5

# c times mean distance measurement error
D_MIN = 0.002


# Euclideandistance between Pose2D (p1, p2)
def d(p1, p2):
	return sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 )

# Look for the robot from GT system
def acquire_robot_position():
	robot_visible = False
	while not robot_visible:
		try:
			((x, y, _), q) = listener.lookupTransform("/world", "/robot_at_work", rospy.Time(0))
			(_, _, theta) = tf.transformations.euler_from_quaternion(q)
			
			return Pose2D(x, y, theta)

			robot_visible = True #TODO: useles.
			
		except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
			rospy.loginfo("Robot position couldn't be acquired, retrying...")
			robot_visible = False
	
			listener.waitForTransform("/world", "/robot_at_work", rospy.Time(), rospy.Duration(2.0)) # TODO NOT GOOD FOR path sampling
			

def main():

	# Init benchmarking node
	benchmark = BmBox()
	rospy.loginfo("FBM3W benchmarking node started")
	
	# init tf
	tf_listener = tf.TransformListener()
	tf_broadcaster = tf.TransformBroadcaster()

	# Get items
	runs_specifications = rospy.get_param('runs_specifications')
	
	# Variables to compute score
	current_run = 0

	# Wait for client
	benchmark.WaitClient()

	# Start the benchmark
	for run in runs_specifications:
		# if the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
		if not benchmark.Running(): break;
		
		
		
		### reference_position, robot and printed path positioning
		
		# TODO ? robot positioning as goal or as precondition
	#	...
		
		# Acquire reference_position
		robot_reference_position = acquire_robot_position()
		
		# Wait for manual operation
		rospy.loginf("Waiting for manual calibration of REFERENCE_POSITION of the printed path")
		manual_operation_result_reference_position = benchmark.ManualOperation()
		
		# If the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
		if not benchmark.Running(): break;
		
		
		
		### starting_position, robot and printed path positioning
		
		# Robot positioning as goal
		benchmark.SendGoal("go to starting position")
		goal_result_starting_position = benchmark.WaitResult()
		
		# Acquire starting_position
		robot_starting_position = acquire_robot_position()
		
		# Wait for manual operation
		rospy.loginf("Waiting for manual calibration of STARTING_POSITION of the printed path")
		manual_operation_result_starting_position = benchmark.ManualOperation()
		
		# If the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
		if not benchmark.Running(): break;
		
		
		
		### path following
		
		# Start collecting robot positions
	#	...
		
		# Robot starts path following as goal
		benchmark.SendGoal("follow path")
		
	#	start_time = time.time() #TODO needed? where?
		
		# Robot ends path following
		goal_result_path_following = benchmark.WaitResult()
		
		# Ends collecting robot positions
	#	...
		
		
		if benchmark.Timeout():
			print "TIMEOUT"
			execution_time = execution_time + (end_time - start_time)
			continue

		if not benchmark.Running():
			print "NOT RUNNING"
			continue
		
		# Compute accuracy
	#	...
		
		# Evaluate execution time
		execution_time = execution_time + (end_time - start_time)

		rospy.loginfo("Execution time of run %i: %f" % (current_run, execution_time)
		
		current_run = current_run + 1

	# Evaluate final score
	score = {
		None, #TODO: per run details
		'execution_time': execution_time

	}
	
	score_yaml = yaml.dump(score)
	benchmark.SendScore(score_yaml)
	
	# Benchmark concluded
	benchmark.End()

	print score_yaml
	time.sleep(100)
				
if __name__ == '__main__':
	main()
	
