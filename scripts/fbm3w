#!/usr/bin/env python
import math
import random
import time
import yaml

# ROS imports
import rospy
import tf
from rockin_scoring.BmBox import BmBox

# Benchmark runs
BENCHMARK_RUNS = 5

# c times mean distance measurement error
D_MIN = 0.002


# robot path
robot_path = []


# Euclidean distance between Pose2D (p1, p2)
def d(p1, p2):
	return sqrt( (p1.x-p2.x)**2 + (p1.y-p2.y)**2 )

# Look for the robot from GT system
def acquire_robot_position():
	robot_visible = False
	while not robot_visible:
		try:
			((x, y, _), q) = tf_listener.lookupTransform("/world", "/robot_at_work", rospy.Time(0))
			(_, _, theta) = tf.transformations.euler_from_quaternion(q)
			
			return Pose2D(x, y, theta)

			robot_visible = True #TODO: useles.
			
		except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
			rospy.loginfo("Robot position couldn't be acquired, retrying...")
			robot_visible = False
	
			tf_listener.waitForTransform("/world", "/robot_at_work", rospy.Time(), rospy.Duration(2.0)) # TODO NOT GOOD FOR path sampling

# given a robot Pose2D relative to world, returns a Pose2D relative to robot_frame
def translate_robot_pose(robot_pose2D):
	try:
		now = rospy.Time.now()
	
		qr = tf.transformations.quaternion_from_euler(0, 0, robot_pose2D.theta)
		tf_broadcaster.sendTransform( (robot_pose2D.x, robot_pose2D.y, 0.0), qr, now, "/robot_in_frame", "/world")
		tf_listener.waitForTransform("/robot_frame", "/robot_in_frame", now, rospy.Duration(2.0) ) #TODO: 2.0 too much, how short can it get
		return tf_listener.lookupTransform("/robot_frame", "/robot_in_frame", now) # to obtain robot wrt path
		
	except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
		return None #TODO something about it
	
######## to publish robot_frame
#	br.sendTransform(start_translation, ref_to_start_quaternion, now, "/robot_frame", "/world") ## constantly #TODO how?
########	
	

def mocap_callback(pose):
	global robot_path
	if len(robot_path)>0:
		if d(robot_path[-1], pose) >= D_MIN:
			robot_path.append(pose)
			print len(robot_path)
			print pose
	else:
		robot_path.append(pose)
		print len(robot_path)
		print pose


def main():

	# Init benchmarking node
	benchmark = BmBox()
	rospy.loginfo("FBM3W benchmarking node started")
	
	# init tf
	tf_listener = tf.TransformListener()
	tf_broadcaster = tf.TransformBroadcaster()

	# Get items
	runs_specifications = rospy.get_param('runs_specifications')
	
	# Variables to compute score
	current_run = 0
	execution_time = 0.0

	# Wait for client
	benchmark.WaitClient()

	# Start the benchmark
	for run in runs_specifications:
		# if the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
		if not benchmark.Running(): break;
		
		
		
		### reference_position, robot and printed path positioning
		
		# TODO ? robot positioning as goal or as precondition
	#	...
		
		# Acquire reference_position
		robot_reference_position = acquire_robot_position()
		
		# Wait for manual operation
	#	rospy.loginf("Waiting for manual calibration of REFERENCE_POSITION of the printed path")
	#	benchmark.ManualOperation()
		
		# If the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
	#	if not benchmark.Running(): break;
		
		
		
		### starting_position, robot and printed path positioning
		
		# Robot positioning as goal
		benchmark.SendGoal("go to starting position")
		benchmark.WaitResult()
		
		# Acquire starting_position
		robot_starting_position = acquire_robot_position()
		
		# Wait for manual operation
		rospy.loginf("Waiting for manual calibration of STARTING_POSITION of the printed path")
		benchmark.ManualOperation()
		
		# If the benchmark is not running, end the benchmark (i.e. CFH stopped the benchmark -> BmBoxState.END) TODO: verify
		if not benchmark.Running(): break;
		
		
		
		### path following
		
		# Start collecting robot positions
		mocap_subscriber = rospy.Subscriber("/fbm3w/robot_at_work/pose2d", Pose2D, mocap_callback)
		rospy.loginfo('subscribed to "/fbm3w/robot_at_work/pose2d"')
		
		# Robot starts path following as goal
		benchmark.SendGoal("start path following")
		start_time = time.time()
		
		# Robot ends path following
		benchmark.WaitResult()
		end_time = time.time()
		
		# Ends collecting robot positions
		mocap_subscriber.unregister()
		rospy.loginfo('UNsubscribed from "/fbm3w/robot_at_work/pose2d"')
		
		if benchmark.Timeout():
			print "TIMEOUT"
			execution_time = execution_time + (end_time - start_time)
			continue

		if not benchmark.Running():
			print "NOT RUNNING"
			continue
		
		# Compute accuracy
	#	...
		
		# Evaluate execution time
		execution_time = execution_time + (end_time - start_time)

		rospy.loginfo("Execution time of run %i: %f" % (current_run, execution_time)
		
		current_run = current_run + 1

	# Evaluate final score
	score = {
		None, #TODO: per run details
		'execution_time': execution_time
	}
	
	score_yaml = yaml.dump(score)
	benchmark.SendScore(score_yaml)
	
	# Benchmark concluded
	benchmark.End()

	print score_yaml
	time.sleep(100)
				
if __name__ == '__main__':
	main()
	
