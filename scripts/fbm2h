#!/usr/bin/env python
import math
import random
import time
import yaml
from datetime import datetime

# ROS imports
import rospy
import tf
from geometry_msgs.msg import Pose2D
from rockin_scoring.BmBox import BmBox


# mocap data received to get the last pose available
last_robot_pose = None

def mocap_callback(pose):
	global last_robot_pose
	last_robot_pose = pose

def main():
	
	# Init benchmarking node
	benchmark = BmBox()
	rospy.loginfo("FBM2H benchmarking node started")
	
	# init tf and subscribers
#	listener = tf.TransformListener()
#	br = tf.TransformBroadcaster()
	mocap_sub = rospy.Subscriber("/fbm2h/robot_at_home/pose2d", Pose2D, mocap_callback) #TODO: or tf?
	rospy.loginfo('subscribed to "/fbm2h/robot_at_home/pose2d"')
	
	# Get the parameters of the benchmark (waypoints, penalty_time, timeout_time)
	#TODO: what's the format of the yaml data sent as goal payload?
	waypoints = rospy.get_param('waypoints')
	penalty_time = rospy.get_param('penalty_time')
	timeout_time = rospy.get_param('timeout_time')
	
	# The goal payload sent to the client containing the list of all waypoints
	goal_payload_yaml = yaml.dump(waypoints)
	
	# Variables to compute score
	N = len(waypoints) - 1
	i = 1
	sum_d = 0.0 # [m]
	sum_sin = 0.0
	sum_cos = 0.0
	execution_time = 0.0 # [s]
	penalties = 0
	timeouts = 0
	segments_detail = {}
	
	# Wait for client
	benchmark.WaitClient()
	
	# Start the benchmark
	while benchmark.Running() and not benchmark.Timeout() and i <= N:

		# Send goal
		if i == 1: # first run (robot in starting position, next waypoint is p1)
			benchmark.SendGoal(goal_payload_yaml)
		else:
			benchmark.SendGoal()
		
		# initialize the detail for the current segment
		segments_detail[i] = {}
		
		start_segment_time = time.time()
		segments_detail[i]['start_segment_time'] = start_segment_time
		
		# Wait for result from client
		result_yaml			= benchmark.WaitResult() #TODO: verify that if timeout then WaitResult() returns
		
		end_segment_time	= time.time()
		segment_time		= end_segment_time - start_segment_time
		segments_detail[i]['end_segment_time'] = end_segment_time
		segments_detail[i]['segment_time'] = segment_time
		
		target_pose			= Pose2D(waypoints[i]['x'], waypoints[i]['y'], waypoints[i]['theta'])
		robot_pose			= last_robot_pose #TODO copy?
		segments_detail[i]['target_pose'] = target_pose
		segments_detail[i]['robot_pose'] = robot_pose
		
		result = yaml.load(result_yaml)['int']
		segments_detail[i]['result'] = result
		
		if result != i:
			rospy.loginfo( "WRONG WAYPOINT: %s received instead of %s" % (result, i) )
			continue
		
#		TODO: check that the last robot_pose is suitable (i.e. not too old)
		
		if benchmark.Timeout():
			rospy.loginfo( "TIMEOUT" )
			execution_time = execution_time + segment_time
			segments_detail[i]['refbox_timeout'] = True
			continue
		segments_detail[i]['refbox_timeout'] = False
		
		if not benchmark.Running():
			rospy.loginfo( "NOT RUNNING" )
			segments_detail[i]['refbox_not_running'] = True
			continue
		segments_detail[i]['refbox_not_running'] = False
		
		# Enforcing of rule: The maximum time allowed to the robot to go from each waypoint to the next waypoint, without penalization.
		if segment_time > penalty_time:
			rospy.loginfo( "PENALTY APPLIED ON THIS SEGMENT" )
			penalties = penalties + 1
			segments_detail[i]['penalty'] = True
		else:
			segments_detail[i]['penalty'] = False
		
		# Enforcing of rule: If robots spent more time than this deadline when going from one waypoint to the next waypoint, they will not get points on that path. (assuming penalization from precedent rule is implied when this rule is enforced) 
		if segment_time > timeout_time:
			rospy.loginfo( "TIMEOUT ON THIS SEGMENT" )
			execution_time = execution_time + segment_time
			timeouts = timeouts + 1
			segments_detail[i]['timeout'] = True
			i = i + 1
			continue
		segments_detail[i]['timeout'] = False
		
		# Evaluate position and orientation error between target pose (tp) and robot pose (rp)
		rp = robot_pose	# robot position
		tp = target_pose # target position
		
		d_error = math.sqrt( (rp.x-tp.x)**2 + (rp.y-tp.y)**2 )
		sum_d = sum_d + d_error
		
		sin_error = math.sin(math.fabs(rp.theta - tp.theta))
		sum_sin = sum_sin + sin_error
		cos_error = math.cos(math.fabs(rp.theta - tp.theta))
		sum_cos = sum_cos + cos_error
		
		segments_detail[i]['dinstance_error'] = d_error
		segments_detail[i]['orientation_error'] = math.atan2(sin_error, cos_error)
		
		# Evaluate execution time
		execution_time = execution_time + segment_time
		
		rospy.loginfo(" - result from client: %i\n - segment_time: %s\n - dinstance_error: %s\n - orientation_error: %s" % (result, segment_time, segments_detail[i]['dinstance_error'], segments_detail[i]['orientation_error']))
		
		i = i + 1
		
	
	# Evaluate final score
	position_accuracy = sum_d / N
	orientation_accuracy = math.atan2(sum_sin, sum_cos)
	
	score = {
		'position_accuracy': position_accuracy,
		'orientation_accuracy': orientation_accuracy,
		'penalized_segments': penalties,
		'timeout_segments': timeouts,
		'execution_time': execution_time,
		'details': segments_detail
	}
	
	score_yaml = yaml.dump(score)
	benchmark.SendScore(score_yaml)
	
	# Benchmark concluded
	benchmark.End()
	
	print score_yaml
	
	#with open("/home/rockin/fbm2h_score.yaml", 'a') as f:
	#	f.write(datetime.now().isoformat())
	#	f.write(score_yaml)
	#	f.write("\n\n")
	
	raw_input("press ENTER to close")
				
if __name__ == '__main__':
	main()
	
