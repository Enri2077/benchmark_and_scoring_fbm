#!/usr/bin/env python
import math
import random
import time
import yaml
from datetime import datetime

# ROS imports
import rospy
import tf
from geometry_msgs.msg import Pose2D
from rockin_scoring.BmBox import BmBox

# mocap data received to get the latest pose available
#last_robot_pose = None

#def mocap_callback(pose):
#	global last_robot_pose
#	last_robot_pose = pose
#	last_robot_pose_t = time.time()

def main():
	
	# Init benchmarking node
	benchmark = BmBox()
	rospy.loginfo("FBM2H benchmarking node started")
	
	# init tf and subscribers
	tf_listener = tf.TransformListener()
	tf_broadcaster = tf.TransformBroadcaster()
#	mocap_sub = rospy.Subscriber("/fbm2h/robot_at_home/pose2d", Pose2D, mocap_callback)
#	rospy.loginfo('subscribed to "/fbm2h/robot_at_home/pose2d"')
	
	# Get the parameters of the benchmark (waypoints, penalty_time, timeout_time)
	#TODO: what's the format of the yaml data sent as goal payload?
	waypoints = rospy.get_param('waypoints')
	penalty_time = rospy.get_param('penalty_time')
	timeout_time = rospy.get_param('timeout_time')
	
	# The goal payload sent to the client containing the list of all waypoints
	goal_payload_yaml = yaml.dump(waypoints)
	
	# Variables to compute score
	N = len(waypoints) - 1
	i = 1
	sum_d = 0.0 # [m]
	sum_sin = 0.0
	sum_cos = 0.0
	execution_time = 0.0 # [s]
	penalties = 0
	timeouts = 0
	segments_detail = {}
	
	#raw_input("press ENTER to START")
	
	# Aquire the marker-robot transform
	try:
		time.sleep(1.0) # TODO: does it need more time?
		
		now = rospy.Time.now()
		
		# Starting robot pose (the robot is initially posed as the starting pose (waypoint 0))
		(x_r0, y_r0, theta_r0) = (waypoints[0]['x'], waypoints[0]['y'], waypoints[0]['theta'])
		starting_robot_rotation = tf.transformations.quaternion_from_euler(0, 0, theta_r0)

		# broadcast the robot frame relative to the marker
		tf_broadcaster.sendTransform((x_r0, y_r0, 0.0), starting_robot_rotation, now, "/actual_robot", "/world")
		
		# receive the robot transform and compute the robot pose
		tf_listener.waitForTransform("/world", "/actual_robot", now, rospy.Duration(5.0))
		marker_to_robot_transform = tf_listener.lookupTransform("/robot_at_home", "/actual_robot", now)
		
		print  "marker-robot transform aquired: ", marker_to_robot_transform
		
	except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException), Argument:
		rospy.loginfo("marker-robot transform not aquired") #TODO test
		rospy.loginfo(Argument)
	
	# Wait for client
	benchmark.WaitClient()
	
	# Start the benchmark
	while benchmark.Running() and not benchmark.Timeout() and i <= N:

		# Send goal
		if i == 1: # first run (robot in starting position, next waypoint is p1)
			benchmark.SendGoal(goal_payload_yaml)
		else:
			benchmark.SendGoal()
		
		# initialize the detail for the current segment
		segments_detail[i] = {}
		
		start_segment_time = time.time()
		segments_detail[i]['start_segment_time'] = start_segment_time
		
		# Wait for result from client
		result_yaml			= benchmark.WaitResult()
		result = yaml.load(result_yaml)['int']
		segments_detail[i]['result'] = result
		
		if result != i: #TODO: what to do in such case?
			rospy.loginfo( "WRONG WAYPOINT: %s received instead of %s" % (result, i) )
			continue
		
		# Compute segment time
		end_segment_time	= time.time()
		segment_time		= end_segment_time - start_segment_time
		segments_detail[i]['end_segment_time'] = end_segment_time
		segments_detail[i]['segment_time'] = segment_time
		
		# Collect the target and robot poses (using tf)
		try:
			now = rospy.Time.now()
		
			# world_to_marker transform
			tf_listener.waitForTransform("/world", "/robot_at_home", now, rospy.Duration(1.0))
			marker_transform = tf_listener.lookupTransform("/world", "/robot_at_home", now)
		
			# broadcast the robot frame relative to the marker
			tf_broadcaster.sendTransform(marker_to_robot_transform[0], marker_to_robot_transform[1], now, "/actual_robot", "/robot_at_home")
		
			# receive the robot transform and compute the robot pose
			tf_listener.waitForTransform("/world", "/actual_robot", now, rospy.Duration(1.0))
			( (robot_x, robot_y, _), robot_rotation ) = tf_listener.lookupTransform("/world", "/actual_robot", now)
			(_, _, robot_theta) = tf.transformations.euler_from_quaternion(robot_rotation)
		
			robot_pose = Pose2D(robot_x, robot_y, robot_theta)
			target_pose = Pose2D(waypoints[i]['x'], waypoints[i]['y'], waypoints[i]['theta'])
		
			segments_detail[i]['target_pose'] = yaml.dump(target_pose)
			segments_detail[i]['robot_pose']  = yaml.dump(robot_pose)

		except (tf.LookupException):
			rospy.loginfo("Robot pose not available: LookupException") 
		except (tf.ConnectivityException):
			rospy.loginfo("Robot pose not available: ConnectivityException") 
		except (tf.ExtrapolationException), Argument:
			rospy.loginfo("Robot pose not available: ExtrapolationException", Argument) #TODO: what to do in such case? maybe try again
		
		
		if benchmark.Timeout():
			rospy.loginfo( "TIMEOUT" )
			execution_time = execution_time + segment_time
			segments_detail[i]['refbox_timeout'] = True
			continue
		segments_detail[i]['refbox_timeout'] = False
		
		if not benchmark.Running():
			rospy.loginfo( "NOT RUNNING" )
			segments_detail[i]['refbox_not_running'] = True
			continue
		segments_detail[i]['refbox_not_running'] = False
		
		# Enforcing of rule: The maximum time allowed to the robot to go from each waypoint to the next waypoint, without penalization.
		if segment_time > penalty_time:
			rospy.loginfo( "PENALTY APPLIED ON THIS SEGMENT" )
			penalties = penalties + 1
			segments_detail[i]['penalty'] = True
		else:
			segments_detail[i]['penalty'] = False
		
		# Enforcing of rule: If robots spent more time than this deadline when going from one waypoint to the next waypoint, they will not get points on that path. (assuming penalization from precedent rule is implied when this rule is enforced) 
		if segment_time > timeout_time:
			rospy.loginfo( "TIMEOUT ON THIS SEGMENT" )
			execution_time = execution_time + segment_time
			timeouts = timeouts + 1
			segments_detail[i]['timeout'] = True
			i = i + 1
			continue
		segments_detail[i]['timeout'] = False
		
		# Evaluate position and orientation error between target pose (tp) and robot pose (rp)
		rp = robot_pose	# robot position
		tp = target_pose # target position
		
		d_error = math.sqrt( (rp.x-tp.x)**2 + (rp.y-tp.y)**2 )
		sum_d = sum_d + d_error
		
		sin_error = math.sin(math.fabs(rp.theta - tp.theta))
		sum_sin = sum_sin + sin_error
		cos_error = math.cos(math.fabs(rp.theta - tp.theta))
		sum_cos = sum_cos + cos_error
		
		segments_detail[i]['dinstance_error'] = d_error
		segments_detail[i]['orientation_error'] = math.atan2(sin_error, cos_error)
		
		# Update execution time
		execution_time = execution_time + segment_time
		
		rospy.loginfo(" - result from client: %i\n - segment_time: %s\n - dinstance_error: %s\n - orientation_error: %s" % (result, segment_time, segments_detail[i]['dinstance_error'], segments_detail[i]['orientation_error']))
		
		i = i + 1
		
	
	# Evaluate final score
	position_accuracy = sum_d / N
	orientation_accuracy = math.atan2(sum_sin, sum_cos)
	
	score = {
		'position_accuracy': position_accuracy,
		'orientation_accuracy': orientation_accuracy,
		'penalized_segments': penalties,
		'timeout_segments': timeouts,
		'execution_time': execution_time,
		'details': segments_detail
	}
	
	score_yaml = yaml.dump(score, default_flow_style=False)
	print score_yaml
	
	benchmark.SendScore(score_yaml) #TODO: it get stuck here
	
	# Benchmark concluded
	benchmark.End()
	
	#with open("/home/rockin/fbm2h_score.yaml", 'a') as f:
	#	f.write(datetime.now().isoformat())
	#	f.write(score_yaml)
	#	f.write("\n\n")
	
	raw_input("press ENTER to close")
				
if __name__ == '__main__':
	main()
	
